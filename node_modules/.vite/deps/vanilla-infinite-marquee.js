import "./chunk-G3PMV62Z.js";

// node_modules/vanilla-infinite-marquee/infinite-marquee.mjs
var InfiniteMarquee = class {
  constructor(e = {}) {
    this.element = "string" == typeof e.element ? [...document.querySelectorAll(e.element)] : e.element, this.direction = e.direction || "left", this.spaceBetween = e.spaceBetween || "0px", this.gap = { vertical: e.gap && e.gap.vertical || "5px", horizontal: e.gap && e.gap.horizontal || "0px" }, this.speed = e.speed || 1e4, this.fullContainer = e.fullContainer || false, this.fullContainerWidth = e.fullContainerWidth || 100, this.smoothEdges = e.smoothEdges || false, this.pauseOnHover = e.pauseOnHover || false, this.duplicateCount = e.duplicateCount || 1, this.duplicateInnerElements = e.duplicateInnerElements ?? true, this.breakpointSize = e.breakpointSize || 1023, this.desktopBreakpoint = this.breakpointSize + 1, this.mobileSettings = e.mobileSettings || {}, this.destroyOnDesktop = e.destroyOnDesktop || false, this.destroyOnMobile = e.destroyOnMobile || false, this.elementClass = e.elementClass || "marquee-container", this.on = { beforeInit: e.on && e.on.beforeInit || null, afterInit: e.on && e.on.afterInit || null, pauseAnimation: e.on && e.on.pauseAnimation || null, resumeAnimation: e.on && e.on.resumeAnimation || null }, this.scrollType = "top" === e.direction || "bottom" === e.direction ? "vertical" : "horizontal", this.debugging = e.debugging || false, this.animateMotion = true, this.isMarqueeInitialized = false, !this.isMarqueeInitialized && this.init(), "undefined" != typeof window && (this.destroyOnResponsive(), (this.destroyOnMobile || this.destroyOnDesktop) && window.addEventListener("resize", this.destroyOnResponsive.bind(this)));
  }
  init() {
    if ("undefined" == typeof window && "undefined" == typeof document || !(Array.isArray(this.element) ? this.element.length > 0 : this.element)) this.debugging && console.error("ðŸšŠ Infinite Marquee - Failed to Initialize");
    else {
      if (this.debugging && console.log("ðŸšŠ Infinite Marquee - Initialized"), window.matchMedia("(prefers-reduced-motion: reduce)").matches && (this.animateMotion = false, this.debugging && console.log('ðŸšŠ Infinite Marquee - "prefers-reduced-motion" is Reduced')), "function" == typeof this.on.beforeInit && this.on.beforeInit(), Array.isArray(this.element)) {
        this.isMarqueeInitialized = true;
        for (const e of this.element) this.configureChildNodes(e), this.configureAnimationOptions(e);
        this.debugging && console.log("ðŸšŠ Infinite Marquee - DOM Nodes Created from Array");
      } else this.isMarqueeInitialized = true, this.configureChildNodes(this.element), this.configureAnimationOptions(this.element), this.debugging && console.log("ðŸšŠ Infinite Marquee - DOM Nodes Created from Single Element");
      "function" == typeof this.on.afterInit && this.on.afterInit();
    }
  }
  configureChildNodes(e) {
    const t = document.createElement("div");
    for (t.classList.add(`${this.scrollType}-marquee-inner`); e.firstChild; ) t.appendChild(e.firstChild);
    e.classList.add(`${this.scrollType}-marquee`), e.appendChild(t), this.duplicateInnerElements && this.duplicateOriginalNodes(t), this.duplicateContainer(e), this.debugging && console.log("ðŸšŠ Infinite Marquee - DOM Nodes Appended Successfully");
  }
  duplicateOriginalNodes(e) {
    const t = e.children, i = [];
    for (let e2 = 0; e2 < t.length; e2++) {
      const s = t[e2].cloneNode(true);
      s.setAttribute("aria-hidden", true), i.push(s);
    }
    for (const t2 of i) e.appendChild(t2);
    this.debugging && console.log("ðŸšŠ Infinite Marquee - DOM Nodes Duplicated Successfully");
  }
  duplicateContainer(e) {
    const t = e.querySelector(`.${this.scrollType}-marquee-inner`), i = t.cloneNode(true);
    i.setAttribute("aria-hidden", true);
    const s = i.children;
    for (let e2 = 0; e2 < s.length; e2++) s[e2].removeAttribute("aria-hidden");
    const n = "vertical" === this.scrollType ? this.duplicateCount + 1 : this.duplicateCount, o = Array.from({ length: n }, (() => i.cloneNode(true)));
    if (e.append(...o), "vertical" === this.scrollType) {
      const i2 = e.clientHeight - t.clientHeight;
      e.style.setProperty("--_containerSize", `${i2}px`);
    }
  }
  configureAnimationOptions(e) {
    const t = window.matchMedia(`(max-width: ${this.breakpointSize}px)`);
    e.setAttribute("data-animate", this.animateMotion);
    const i = (e2) => {
      e2.addEventListener("mouseenter", (() => this.pause(e2))), e2.addEventListener("mouseleave", (() => this.resume(e2)));
    }, s = () => {
      if (this.isMarqueeInitialized) {
        const s2 = this.mobileSettings.direction || this.direction, n = "right" === s2 || "bottom" === s2, o = "right" === this.direction || "bottom" === this.direction, r = t.matches ? n ? "reverse" : "forwards" : o ? "reverse" : "forwards", l = t.matches && this.mobileSettings.speed || this.speed;
        if (e.style.setProperty("--_speed", `${l}ms`), e.style.setProperty("--_direction", r), this.smoothEdges && e.classList.add("smooth"), "vertical" === this.scrollType) {
          const i2 = t.matches && this.mobileSettings && this.mobileSettings.gap && this.mobileSettings.gap.horizontal || this.gap.horizontal, s3 = t.matches && this.mobileSettings && this.mobileSettings.gap && this.mobileSettings.gap.vertical || this.gap.vertical;
          this.gap.horizontal && e.style.setProperty("--_hGap", i2), this.gap.vertical && e.style.setProperty("--_vGap", s3);
        } else {
          const i2 = t.matches && this.mobileSettings.spaceBetween || this.spaceBetween, s3 = !t.matches && this.fullContainer;
          e.style.setProperty("--_gap", i2), e.classList.toggle("full", s3), e.style.setProperty("--_containerWidth", s3 ? `${this.fullContainerWidth}%` : "");
        }
        window.innerWidth >= this.desktopBreakpoint && this.pauseOnHover && this.animateMotion && i(e), this.debugging && console.log(`ðŸšŠ Infinite Marquee - ${this.scrollType} type`), this.debugging && console.log("ðŸšŠ Infinite Marquee - Animation Configs Ready");
      }
    };
    s(), window.addEventListener("resize", this.debounce(s));
  }
  destroyOnResponsive() {
    const e = `${this.scrollType}-marquee-inner`, t = this.element;
    "undefined" != typeof window && (window.innerWidth <= this.breakpointSize && this.destroyOnMobile || window.innerWidth >= this.desktopBreakpoint && this.destroyOnDesktop ? this.manageMarquee(t, e) : this.isMarqueeInitialized || (this.init(), this.isMarqueeInitialized = true));
  }
  manageMarquee(e, t) {
    this.isMarqueeInitialized && (this.destroy(e, t), this.isMarqueeInitialized = false, this.debugging && console.log("ðŸšŠ Infinite Marquee - Destroyed Successfully"));
  }
  removeClassesAfter(e, t) {
    if (t && t.classList) {
      let i = false;
      for (let s = 0; s < t.classList.length; s++) {
        const n = t.classList[s];
        i && (t.classList.remove(n), s--), n === e && (i = true);
      }
    }
  }
  destroy(e, t) {
    if (e) {
      e.removeAttribute("style");
      const i = e.querySelectorAll(`.${t}`);
      for (let t2 = 1; t2 < i.length; t2++) e.removeChild(i[t2]);
      const s = e.firstElementChild;
      if (s) {
        if (s.querySelectorAll('[aria-hidden="true"]').forEach(((e2) => {
          s.removeChild(e2);
        })), s.classList.contains(t)) {
          for (; s.firstChild; ) e.appendChild(s.firstChild);
          e.removeChild(s), this.removeClassesAfter(this.elementClass, e);
        }
      }
    }
  }
  pause(e) {
    (e || this.element).classList.add("paused"), this.debugging && console.log("ðŸšŠ Infinite Marquee - Animation Paused"), "function" == typeof this.on.pauseAnimation && this.on.pauseAnimation();
  }
  resume(e) {
    (e || this.element).classList.remove("paused"), this.debugging && console.log("ðŸšŠ Infinite Marquee - Animation Resumed"), "function" == typeof this.on.resumeAnimation && this.on.resumeAnimation();
  }
  debounce(e, t = 300) {
    let i;
    return (...s) => {
      i && clearTimeout(i), i = setTimeout((() => {
        e(...s);
      }), t);
    };
  }
};
export {
  InfiniteMarquee as default
};
//# sourceMappingURL=vanilla-infinite-marquee.js.map
